<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Map Maker for Diamond Game</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #303030;
		}
	</style>
	<script src="pixi.js"></script>
</head>
<body>
	<form onsubmit="go('outputText'); return false;">
	  <input type="text" name="out" id="outputText" value=""></input>
		<input type="submit" name="submit" value="Output">
	</form>
	<input type="file" name="file" id="file">
	<output id="list"></output>
	<script>

		//PIXI Stuff

		var stage = new PIXI.Stage(0x505050);
		var renderer = PIXI.autoDetectRenderer(1000, 600); //Should make the size the size of the window eventually.
		document.body.appendChild(renderer.view);
		requestAnimFrame(animate);

		//----------------------------------- Textures

		var personTexture = PIXI.Texture.fromImage("images/character/guy.png");

		var topTexture = new Array(10);//[tile set][image]
		for(var i = 0; i < topTexture.length; i++){
			topTexture[i] = new Array(10);
		}
		for(var i = 0; i < 1; i++){//Constant: number of tile sets
			for(var j = 0; j < 5; j++){//Constant: number of textures (on all of these.)
				topTexture[i][j] = PIXI.Texture.fromImage("images/tile/"+i+"/top"+j+".png");
			}
		}

		var sideTexture = new Array(10);
		for(var i = 0; i < sideTexture.length; i++){
			sideTexture[i] = new Array(10);
		}
		for(var i = 0; i < 1; i++){
			for(var j = 0; j < 3; j++){
				sideTexture[i][j] = PIXI.Texture.fromImage("images/tile/"+i+"/side"+j+".png");
			}
		}

		var envTexture = new Array(10);
		for(var i = 1; i < 2; i++){
			envTexture[i] = PIXI.Texture.fromImage("images/object/env/"+i+".png");
		}

		var envcTexture = new Array(10);
		for(var i = 1; i < 4; i++){
			envcTexture[i] = PIXI.Texture.fromImage("images/object/envc/"+i+".png");
		}

		//----------------------------------- VARIABLES

		versionNumber = "Map Maker 0.2";

		var start = 100; //Depends on other things. Should be centered. Scrolling landscapes too. //FINAL
		var layers = 50; //Temp variable. Don't know what this will eventually be. //FINAL

		var tileWidth = 50; //Size of the tile images in pixels
		var tileHeight = 24;
		var sideHeight = 9;

		var left = false; //Keyboard inputs.
		var up = false;
		var right = false;
		var down = false;
		var space = false;
		var shift = false;

		var cameraX = 0;
		var cameraY = 0;

		var speed = 4; // Unlike in the normal game, speed is the camera scrolling speed.

		var mouseMode = 0;

		var bgSpan = 10;

		//---------------------------------------- layers

		var area = new PIXI.DisplayObjectContainer(); //Main game container.
		stage.addChild(area);

		var levels = new Array(layers);
		for(var i = 0; i < layers; i++){
			levels[i] = new PIXI.DisplayObjectContainer();
		}
		var envLevels = new Array(layers);
		for(var i = 0; i < layers; i++){
			envLevels[i] = new PIXI.DisplayObjectContainer();
		}
		var bg1 = new PIXI.DisplayObjectContainer();
		var bg2 = new PIXI.DisplayObjectContainer();

		area.addChild(bg1);
		for(var i = 0; i < layers; i++){
				area.addChild(levels[i]);
				area.addChild(envLevels[i]);
		}
		area.addChild(bg2);

		//---------------------------------------- Version text

		var version = new PIXI.Text("Version: " + versionNumber, {font: "12px Arial", fill: "white"});

		version.position.x = version.position.y = 10;

		stage.addChild(version);

		//---------------------------------------- Map

		var sizeX = 0;
		var sizeY = 0;

		var outside = {
			h: 0,
			top: 0,
			side: 0,
		}

		var tileSet = 0;

		var map = new Array(50);
		for(var i = 0; i < map.length; i++){
			map[i] = new Array(50);
		}

		for(var i = 0; i < 50; i++){
			for(var j = 0; j < 50; j++){
				map[i][j] = {
					h: 0,
					top: 0,
					side: 0,
					env: 0,
					envc: 0,
					cr: false, // lower right (collisions)
					cl: false, // lower left
					e: 0
				}
			}
		}

		function mapIn(m){

			sizeX = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			sizeY = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.h = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.top = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.side = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			tileSet = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					map[i][j].h = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].top = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].side = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].env = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].envc = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].cr = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].cl = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].e = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
				}
			}
			reload();
			drawMap();
		}

		//----------------------------------------- Output Things

		function go(outputText){
			var field = document.getElementById(outputText);
			var o = "";
			o += sizeX + " ";
			o += sizeY + " ";
			o += outside.h + " ";
			o += outside.top + " ";
			o += outside.side + " ";
			o += tileSet + " ";
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					o += map[i][j].h + " ";
					o += map[i][j].top + " ";
					o += map[i][j].side + " ";
					o += map[i][j].env + " ";
					o += map[i][j].envc + " ";
					o += map[i][j].cr + " ";
					o += map[i][j].cl + " ";
					o += map[i][j].e + " ";
				}
			}
			field.value = o;
		}

		function readSingleFile(evt){
			var f = evt.target.files[0];

			if(f){
				var r = new FileReader();
				r.onload = function(e){
					var contents = e.target.result;
					mapIn(contents);
				}
				r.readAsText(f);
			}
		}
		document.getElementById('file').addEventListener('change', readSingleFile, false);


		//-------------------------------------------- INPUT

		document.addEventListener('keydown', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = true;
			}
			if(code == 87 || code == 38){ //W
				up = true;
			}
			if(code == 68 || code == 39){ //D
				right = true;
			}
			if(code == 83 || code == 40){ //S
				down = true;
			}
			if(code == 32){ //Space
				space = true;
			}
			if(code == 16){ //Shift
				shift = true;
			}
		});

		document.addEventListener('keyup', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = false;
			}
			if(code == 87 || code == 38){ //W
				up = false;
			}
			if(code == 68 || code == 39){ //D
				right = false;
			}
			if(code == 83 || code == 40){ //S
				down = false;
			}
			if(code == 32){ //Space
				space = false;
			}
			if(code == 16){ //Shift
				shift = false;
			}
		});

		//--------------------------------------------------------------------- GAME LOOP

		function animate(){
			requestAnimFrame(animate);

			update();

			renderer.render(stage);
		}

		function update(){
			var speedAfter = speed; // Camera speed up. This feels like messy code but whatever.
			if(shift){
				speedAfter += 4;
			}
			if(left && !right){
				cameraX -= speedAfter;
			}
			if(up && !down){
				cameraY -= speedAfter;
			}
			if(right && !left){
				cameraX += speedAfter;
			}
			if(down && !up){
				cameraY += speedAfter;
			}

			area.position.x = -cameraX;
			area.position.y = -cameraY;
		}

		function reload(){
			while(bg1.children.length > 0){
				bg1.removeChild(bg1.getChildAt(0));
			}
			for(var i = 0; i < levels.length; i++){
				while(levels[i].children.length > 0){
					levels[i].removeChild(levels[i].getChildAt(0));
				}
			}
			for(var i = 0; i < levels.length; i++){
				while(envLevels[i].children.length > 0){
					envLevels[i].removeChild(envLevels[i].getChildAt(0));
				}
			}
			while(bg2.children.length > 0){
				bg2.removeChild(bg2.getChildAt(0));
			}
		}

		function drawMap(){
			for(var i = -bgSpan; i < bgSpan + sizeX; i++){
				for(var j = -bgSpan; j < bgSpan + sizeY; j++){
					var bgroud1 = (i < 0 || j < 0);
					var ground2 = (i >= sizeX || j >= sizeY);
					if(bgroud1){
						var tile = new PIXI.Sprite(topTexture[tileSet][outside.top]);

						tile.anchor.x = 0.5;
						tile.anchor.y = 1;

						tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * outside.h) + (tileHeight/2);

						bg1.addChild(tile);

						for(var k = outside.h; k > 0; k--){
							if(j >= 0 && j < sizeY && i == -1){
								var under = new PIXI.Sprite(sideTexture[tileSet][outside.side]);

								under.anchor.x = 0.5;
								tile.anchor.y = 1;

								under.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
								under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

								bg1.addChild(under);
							}

							if(i >= 0 && i < sizeX && j == -1){
								var under2 = new PIXI.Sprite(sideTexture[tileSet][outside.side]);

								under2.anchor.x = 0.5;
								tile.anchor.y = 1;

								under2.scale.x = -1;

								under2.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
								under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

								bg1.addChild(under2);
							}
						}

					}else if(ground2){
						var tile = new PIXI.Sprite(topTexture[tileSet][outside.top]);

						tile.anchor.x = 0.5;
						tile.anchor.y = 1;

						tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * outside.h) + (tileHeight/2);

						bg2.addChild(tile);
					}
				}
			}
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					var tile = new PIXI.Sprite(topTexture[tileSet][map[i][j].top]);

					tile.anchor.x =0.5
					tile.anchor.y = 1;

					tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
					tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

					tile.hitArea = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(-tileWidth/2, -tileHeight/2), new PIXI.Point(0, -tileHeight), new PIXI.Point(tileWidth/2, -tileHeight/2));

					tile.interactive = true;

					tile.mousedown = function(data){
						if(mouseMode == 0){ // Height edit
							var newHeight = prompt("Enter new height."); // Move this to and input element in HTML part
							if(newHeight >= 0){
								var ci = 0;
								var cj = 0;
								var close = 1000;
								for(var i = 0; i < sizeX; i++){
									for(var j = 0; j < sizeY; j++){
										var distance = Math.abs((sizeY - 1 + i - j) * (tileWidth/2) + start - this.position.x) + (Math.abs((i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2) - this.position.y) * 1.5);
										if(distance < close){
											ci = i;
											cj = j;
											close = distance;
										}
									}
								}
								console.log(this.position.x + " " + this.position.y);
								console.log(distance);
								map[ci][cj].h = newHeight;
								reload();
								drawMap();
							}
						}
					}

					levels[i + j].addChild(tile);

					for(var k = map[i][j].h; k > 0; k--){
						if(i == sizeX - 1 || k > map[i+1][j].h){
							var under = new PIXI.Sprite(sideTexture[tileSet][map[i][j].side]);

							under.anchor.x = 0.5;
							tile.anchor.y = 1;

							under.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
							under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

							levels[i + j].addChild(under);
						}

						if(j == sizeY - 1 || k > map[i][j+1].h){
							var under2 = new PIXI.Sprite(sideTexture[tileSet][map[i][j].side]);

							under2.anchor.x = 0.5;
							tile.anchor.y = 1;

							under2.scale.x = -1;

							under2.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
							under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

							levels[i + j].addChild(under2);
						}
					}

					//Objects
					if(map[i][j].env != 0){
						var env = new PIXI.Sprite(envTexture[map[i][j].env]);

						env.anchor.x = 0.5
						env.anchor.y = 1;

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h);

						envLevels[i + j].addChild(env);
					}
					if(map[i][j].envc != 0){
						var env = new PIXI.Sprite(envcTexture[map[i][j].envc]);

						env.anchor.x = 0.5
						env.anchor.y = 1;

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

						levels[i + j + 1].addChild(env);
					}
				}
			}
		}
	</script>
</body>
