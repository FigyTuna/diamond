<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Map Maker for Diamond Game</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #303030;
		}
	</style>
	<script src="pixi.js"></script>
</head>
<body>
  <form onsubmit="newMap('mx', 'my', 'ts'); return false;">
    <input type="text" name="mx" id="mx" value="Size (X)"></input>
    <input type="text" name="my" id="my" value="Size (Y)"></input>
    <input type="text" name="ts" id="ts" value="Tile Set"></input>
    <input type="submit" name="submit" value="New">
  </form>
	<form onsubmit="go('outputText'); return false;">
	  <input type="text" name="out" id="outputText" value=""></input>
		<input type="submit" name="submit" value="Save">
    <input type="file" name="file" id="file">
	</form>
  <form onsubmit="eventM('e'); return false;">
    <input type="text" name="e" id="e" value="New Event"></input>
    <input type="submit" name="submit" value="Event">
  </form>
	<script>

		//PIXI Stuff

		var stage = new PIXI.Stage(0x505050);
		var renderer = PIXI.autoDetectRenderer(1000, 600); //Should make the size the size of the window eventually.
		document.body.appendChild(renderer.view);
		requestAnimFrame(animate);

		//----------------------------------- Textures

		var topTexture = new Array(1);//[tile set][image]
		for(var i = 0; i < topTexture.length; i++){
			topTexture[i] = new Array(10);
		}
		for(var i = 0; i < 1; i++){//Constant: number of tile sets
			for(var j = 0; j < 10; j++){//Constant: number of textures (on all of these.)
				topTexture[i][j] = PIXI.Texture.fromImage("images/tile/"+i+"/top"+j+".png");
			}
		}

		var sideTexture = new Array(1);
		for(var i = 0; i < sideTexture.length; i++){
			sideTexture[i] = new Array(5);
		}
		for(var i = 0; i < 1; i++){
			for(var j = 0; j < 5; j++){
				sideTexture[i][j] = PIXI.Texture.fromImage("images/tile/"+i+"/side"+j+".png");
			}
		}

		var envTexture = new Array(3);
    envTexture[0] = PIXI.Texture.fromImage("images/mapmaker/clearEnv.png");
		for(var i = 1; i < 3; i++){
			envTexture[i] = PIXI.Texture.fromImage("images/object/env/"+i+".png");
		}

		var envcTexture = new Array(4);
    envcTexture[0] = PIXI.Texture.fromImage("images/mapmaker/clearEnv.png");
		for(var i = 1; i < 4; i++){
			envcTexture[i] = PIXI.Texture.fromImage("images/object/envc/"+i+".png");
		}

		var heightHudTexture = new PIXI.Texture.fromImage("images/mapmaker/height.png");
    var topHudTexture = new PIXI.Texture.fromImage("images/mapmaker/top.png");
    var sideHudTexture = new PIXI.Texture.fromImage("images/mapmaker/side.png");
    var collHudTexture = new PIXI.Texture.fromImage("images/mapmaker/coll.png");
    var envHudTexture = new PIXI.Texture.fromImage("images/mapmaker/env.png");
    var envcHudTexture = new PIXI.Texture.fromImage("images/mapmaker/envc.png");

		var windowTexture = new PIXI.Texture.fromImage("images/mapmaker/window.png");
		var fillTexture = new PIXI.Texture.fromImage("images/mapmaker/fill.png");
		var scrollTexture = new PIXI.Texture.fromImage("images/mapmaker/scroll.png");
    var collTexture = new PIXI.Texture.fromImage("images/mapmaker/collSide.png");

		//----------------------------------- VARIABLES

		versionNumber = "Map Maker 1.2 (Fill tool added. Hold Shift to use.)";

		var start = 100; //Depends on other things. Should be centered. Scrolling landscapes too. //FINAL
		var layers = 50; //Temp variable. Don't know what this will eventually be. //FINAL

		var tileWidth = 50; //Size of the tile images in pixels
		var tileHeight = 24;
		var sideHeight = 9;

		var left = false; //Keyboard inputs.
		var up = false;
		var right = false;
		var down = false;
		var space = false;
		var shift = false;

		var cameraX = 0;
		var cameraY = 0;

		var speed = 4; // Unlike in the normal game, speed is the camera scrolling speed.

    var bgSpan = 10;

		var mouseMode = 0;
    var toolValue = 0;
		var fillNext = {
			x: 0,
			y: 0,
			on: false
		};

		//---------------------------------------- layers

		var area = new PIXI.DisplayObjectContainer(); //Main game container.
		stage.addChild(area);

		var levels = new Array(layers);
		for(var i = 0; i < layers; i++){
			levels[i] = new PIXI.DisplayObjectContainer();
		}
		var envLevels = new Array(layers);
		for(var i = 0; i < layers; i++){
			envLevels[i] = new PIXI.DisplayObjectContainer();
		}
		var bg1 = new PIXI.DisplayObjectContainer();
		var bg2 = new PIXI.DisplayObjectContainer();
		var fillContainer = new PIXI.DisplayObjectContainer();

		area.addChild(bg1);
		for(var i = 0; i < layers; i++){
				area.addChild(levels[i]);
				area.addChild(envLevels[i]);
		}
		area.addChild(bg2);
		area.addChild(fillContainer);

		//---------------------------------------- Version text

		var version = new PIXI.Text("Version: " + versionNumber, {font: "12px Arial", fill: "white"});

		version.position.x = version.position.y = 10;

		stage.addChild(version);

    //---------------------------------------- Map

    var sizeX = 0;
    var sizeY = 0;

    var outside = {
      h: 0,
      top: 2,
      side: 0,
    }

    var tileSet = 0;

    var map = new Array(50);
    for(var i = 0; i < map.length; i++){
      map[i] = new Array(50);
    }

    for(var i = 0; i < 50; i++){
      for(var j = 0; j < 50; j++){
        map[i][j] = {
          h: 0,
          top: 0,
          side: 0,
          env: 0,
          envc: 0,
          cr: false, // lower right (collisions)
          cl: false, // lower left
          e: 0
        }
      }
    }

    //--------------------------------------- HUD

    var extra = new PIXI.DisplayObjectContainer();
		var buttons = new PIXI.DisplayObjectContainer();
    function clearExtra(){
      while(extra.children.length > 0){
        extra.removeChild(extra.getChildAt(0));
      }
			for(var i = 0; i < buttons.children.length; i++){
				buttons.getChildAt(i).tint = 0xFFFFFF;
			}
    }

    var hudPosX = 20;
    var hudPosY = 30;
    var hudButtonHeight = 40;

		function buildButton(b, id, t){
			b.position.x = hudPosX;
			b.position.y = hudPosY + (hudButtonHeight * id);
			b.interactive = true;
			b.mousedown = function(data){
				clearExtra();
				b.tint = 0x606060;
				if(mouseMode != id){
					toolValue = 0;
				}
				buildWindow(t);

				mouseMode = id;
				reload();
				drawMap();
			}
			buttons.addChild(b);
		}

		function buildWindow(t){
			function checkRange(tv){
				if(tv < 0){
					tv = t.length - 1;
				}
				if(tv >= t.length){
					tv = 0;
				}
				return tv;
			}

			var tvu = checkRange(toolValue - 1);
			var tvd = checkRange(toolValue + 1);

			var w = new PIXI.Sprite(windowTexture);
			w.position.x = hudPosX + 80;
			w.position.y = hudPosY + 5;
			extra.addChild(w);

			var upScroll = new PIXI.Sprite(scrollTexture);
			upScroll.anchor.x = 0.5;
			upScroll.position.x = hudPosX + 120;
			upScroll.position.y = hudPosY + 8;
			upScroll.interactive = true;
			upScroll.mousedown = function(data){
				toolValue--;
				toolValue = checkRange(toolValue);
				clearExtra();
				buildWindow(t);
			}
			extra.addChild(upScroll);
			var sel = new PIXI.Sprite(t[tvu]);
			sel.anchor.x = 0.5;
			sel.position.x = hudPosX + 120;
			sel.position.y = hudPosY + 8 + (1 * 44);
			extra.addChild(sel);
			var sel2 = new PIXI.Sprite(t[toolValue]);
			sel2.anchor.x = 0.5;
			sel2.position.x = hudPosX + 120;
			sel2.position.y = hudPosY + 8 + (2 * 44);
			extra.addChild(sel2);
			var sel3 = new PIXI.Sprite(t[tvd]);
			sel3.anchor.x = 0.5;
			sel3.position.x = hudPosX + 120;
			sel3.position.y = hudPosY + 8 + (3 * 44);
			extra.addChild(sel3);
			var downScroll = new PIXI.Sprite(scrollTexture);
			downScroll.anchor.x = 0.5;
			downScroll.anchor.y = 1;
			downScroll.scale.y = -1;
			downScroll.position.x = hudPosX + 120;
			downScroll.position.y = hudPosY + 8 + (4 * 44);
			downScroll.interactive = true;
			downScroll.mousedown = function(data){
				toolValue++;
				toolValue = checkRange(toolValue);
				clearExtra();
				buildWindow(t);
			}
			extra.addChild(downScroll);
		}

		var heightButton = new PIXI.Sprite(heightHudTexture); // Specific buildButton
		heightButton.position.x = hudPosX;
		heightButton.position.y = hudPosY + (hudButtonHeight * 0);
		heightButton.interactive = true;
		heightButton.mousedown = function(data){
			clearExtra();
			heightButton.tint = 0x606060;
			if(mouseMode != 0){
				toolValue = 0;
			}else{
				if(shift){
					toolValue--;
					if(toolValue < 0){
						toolValue = 16 - 1;
					}
				}else{
					toolValue++;
					if(toolValue >= 16){
						toolValue = 0;
					}
				}
			}
			var w = new PIXI.Sprite(windowTexture);
			w.position.x = hudPosX + 80;
			w.position.y = hudPosY + 5;
			extra.addChild(w);
			var sel = new PIXI.Text(toolValue, {font: "16px Arial", fill: "white"});
			sel.position.x = hudPosX + 100;
			sel.position.y = hudPosY + 100;
			extra.addChild(sel);
			mouseMode = 0;
			reload();
			drawMap();
		}
		buttons.addChild(heightButton);

    var topButton = new PIXI.Sprite(topHudTexture);
		buildButton(topButton, 1, topTexture[tileSet]);

    var sideButton = new PIXI.Sprite(sideHudTexture);
    buildButton(sideButton, 2, sideTexture[tileSet]);

    var collButton = new PIXI.Sprite(collHudTexture); // Specific buildButton
    collButton.position.x = hudPosX;
    collButton.position.y = hudPosY + (hudButtonHeight * 3);
    collButton.interactive = true;
    collButton.mousedown = function(data){
      clearExtra();
			collButton.tint = 0x606060;
      mouseMode = 3;
      reload();
      drawMap();
    }
    buttons.addChild(collButton);

    var envButton = new PIXI.Sprite(envHudTexture);
    buildButton(envButton, 4, envTexture);

    var envcButton = new PIXI.Sprite(envcHudTexture);
    buildButton(envcButton, 5, envcTexture);

		stage.addChild(buttons);
    stage.addChild(extra);

    function eventM(e){
      alert("This does nothing yet.");
    }

    //---------------------------------------------------------- New map

    function newMap(mx, my, ts){
      var f = document.getElementById(mx);
      sizeX = parseInt(f.value);
      f.value = "x";
      var f2 = document.getElementById(my);
      sizeY = parseInt(f2.value);
      f2.value = "y";
      var f3 = document.getElementById(ts);
      tileSet = parseInt(f3.value);
      f3.value = "t";

      for(var i = 0; i < sizeX; i++){
        for(var j = 0; j < sizeY; j++){
          map[i][j] = {
            h: 0,
            top: 0,
            side: 0,
            env: 0,
            envc: 0,
            cr: false, // lower right (collisions)
            cl: false, // lower left
            e: 0
          }
        }
      }

      reload();
      drawMap();
    }

    //----------------------------------------------------------- Map input

    function readSingleFile(evt){
      var f = evt.target.files[0];

      if(f){
        var r = new FileReader();
        r.onload = function(e){
          var contents = e.target.result;
          mapIn(contents);
        }
        r.readAsText(f);
      }
    }

    document.getElementById('file').addEventListener('change', readSingleFile, false);

		function mapIn(m){

			sizeX = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			sizeY = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.h = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.top = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			outside.side = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			tileSet = parseInt(m.substring(0, m.indexOf(" ")));
			m = m.substring(m.indexOf(" ") + 1);

			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					map[i][j].h = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].top = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].side = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].env = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].envc = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].cr = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].cl = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
					map[i][j].e = parseInt(m.substring(0, m.indexOf(" ")));
					m = m.substring(m.indexOf(" ") + 1);
				}
			}
			reload();
			drawMap();
		}

		//----------------------------------------- Map output

		function go(outputText){
			var field = document.getElementById(outputText);
			var o = "";
			o += sizeX + " ";
			o += sizeY + " ";
			o += outside.h + " ";
			o += outside.top + " ";
			o += outside.side + " ";
			o += tileSet + " ";
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					o += map[i][j].h + " ";
					o += map[i][j].top + " ";
					o += map[i][j].side + " ";
					o += map[i][j].env + " ";
					o += map[i][j].envc + " ";
					o += (0 + map[i][j].cr) + " "; // Not sure if +0 is needed.
					o += (0 + map[i][j].cl) + " ";
					o += map[i][j].e + " ";
				}
			}
			field.value = o;
		}

		//-------------------------------------------- INPUT

		document.addEventListener('keydown', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = true;
			}
			if(code == 87 || code == 38){ //W
				up = true;
			}
			if(code == 68 || code == 39){ //D
				right = true;
			}
			if(code == 83 || code == 40){ //S
				down = true;
			}
			if(code == 32){ //Space
				space = true;
			}
			if(code == 16){ //Shift
				shift = true;
			}
		});

		document.addEventListener('keyup', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = false;
			}
			if(code == 87 || code == 38){ //W
				up = false;
			}
			if(code == 68 || code == 39){ //D
				right = false;
			}
			if(code == 83 || code == 40){ //S
				down = false;
			}
			if(code == 32){ //Space
				space = false;
			}
			if(code == 16){ //Shift
				shift = false;
			}
		});

		//--------------------------------------------------------------------- GAME LOOP

		function animate(){
			requestAnimFrame(animate);

			update();

			renderer.render(stage);
		}

		function update(){
			var speedAfter = speed; // Camera speed up. This feels like messy code but whatever.
			if(shift){
				speedAfter += 4;
			}
			if(left && !right){
				cameraX -= speedAfter;
			}
			if(up && !down){
				cameraY -= speedAfter;
			}
			if(right && !left){
				cameraX += speedAfter;
			}
			if(down && !up){
				cameraY += speedAfter;
			}

			area.position.x = -cameraX;
			area.position.y = -cameraY;
		}

		function reload(){
			while(bg1.children.length > 0){
				bg1.removeChild(bg1.getChildAt(0));
			}
			for(var i = 0; i < levels.length; i++){
				while(levels[i].children.length > 0){
					levels[i].removeChild(levels[i].getChildAt(0));
				}
			}
			for(var i = 0; i < levels.length; i++){
				while(envLevels[i].children.length > 0){
					envLevels[i].removeChild(envLevels[i].getChildAt(0));
				}
			}
			while(bg2.children.length > 0){
				bg2.removeChild(bg2.getChildAt(0));
			}
		}

		function changeTile(ci, cj){
			if(mouseMode == 0){
				if(toolValue >= 0){// Move to other error handled blahalbjasdohjb
					map[ci][cj].h = toolValue;
				}
			}else if(mouseMode == 1){
				map[ci][cj].top = toolValue;
			}else if(mouseMode == 2){
				map[ci][cj].side = toolValue;
			}else if(mouseMode == 3){
				if(!map[ci][cj].cl && !map[ci][cj].cr){
					map[ci][cj].cl = 1;
				}else if(map[ci][cj].cl && !map[ci][cj].cr){
					map[ci][cj].cl = 0;
					map[ci][cj].cr = 1;
				}else if(!map[ci][cj].cl && map[ci][cj].cr){
					map[ci][cj].cl = 1;
				}else{
					map[ci][cj].cl = 0;
					map[ci][cj].cr = 0;
				}
			}else if(mouseMode == 4){
				map[ci][cj].env = toolValue;
			}else if(mouseMode == 5){
				map[ci][cj].envc = toolValue;
			}
		}

		function drawMap(){
			for(var i = -bgSpan; i < bgSpan + sizeX; i++){
				for(var j = -bgSpan; j < bgSpan + sizeY; j++){
					var bgroud1 = (i < 0 || j < 0);
					var ground2 = (i >= sizeX || j >= sizeY);
					if(bgroud1){
						var tile = new PIXI.Sprite(topTexture[tileSet][outside.top]);

						tile.anchor.x = 0.5;
						tile.anchor.y = 1;

						tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * outside.h) + (tileHeight/2);

            tile.hitArea = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(-tileWidth/2, -tileHeight/2), new PIXI.Point(0, -tileHeight), new PIXI.Point(tileWidth/2, -tileHeight/2));

            tile.interactive = true;

            tile.mousedown = function(data){
              var ci = 0;
              var cj = 0;
              var close = 1000;
              for(var i = 0; i < sizeX; i++){
                for(var j = 0; j < sizeY; j++){
                  var distance = Math.abs((sizeY - 1 + i - j) * (tileWidth/2) + start - this.position.x) + (Math.abs((i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2) - this.position.y) * 1.5);
                  if(distance < close){
                    ci = i;
                    cj = j;
                    close = distance;
                  }
                }
              }
              if(mouseMode == 0){
                if(toolValue >= 0){
                  outside.h = toolValue;
                  reload();
                  drawMap();
                }
              }else if(mouseMode == 1){
                outside.top = toolValue;
                reload();
                drawMap();
              }else if(mouseMode == 2){
                outside.side = toolValue;
                reload();
                drawMap();
              }
            }

						bg1.addChild(tile);

						for(var k = outside.h; k > 0; k--){
							if(j >= 0 && j < sizeY && i == -1){
								var under = new PIXI.Sprite(sideTexture[tileSet][outside.side]);

								under.anchor.x = 0.5;
								tile.anchor.y = 1;

								under.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
								under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

								bg1.addChild(under);
							}

							if(i >= 0 && i < sizeX && j == -1){
								var under2 = new PIXI.Sprite(sideTexture[tileSet][outside.side]);

								under2.anchor.x = 0.5;
								tile.anchor.y = 1;

								under2.scale.x = -1;

								under2.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
								under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

								bg1.addChild(under2);
							}
						}

					}else if(ground2){
						var tile = new PIXI.Sprite(topTexture[tileSet][outside.top]);

						tile.anchor.x = 0.5;
						tile.anchor.y = 1;

						tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * outside.h) + (tileHeight/2);

            tile.hitArea = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(-tileWidth/2, -tileHeight/2), new PIXI.Point(0, -tileHeight), new PIXI.Point(tileWidth/2, -tileHeight/2));

            tile.interactive = true;

            tile.mousedown = function(data){
              var ci = 0;
              var cj = 0;
              var close = 1000;
              for(var i = 0; i < sizeX; i++){
                for(var j = 0; j < sizeY; j++){
                  var distance = Math.abs((sizeY - 1 + i - j) * (tileWidth/2) + start - this.position.x) + (Math.abs((i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2) - this.position.y) * 1.5);
                  if(distance < close){
                    ci = i;
                    cj = j;
                    close = distance;
                  }
                }
              }
              if(mouseMode == 0){
                if(toolValue >= 0){
                  outside.h = toolValue;
                  reload();
                  drawMap();
                }
              }else if(mouseMode == 1){
                outside.top = toolValue;
                reload();
                drawMap();
              }else if(mouseMode == 2){
                outside.side = toolValue;
                reload();
                drawMap();
              }
            }

						bg2.addChild(tile);
					}
				}
			}
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					var tile = new PIXI.Sprite(topTexture[tileSet][map[i][j].top]);

					tile.anchor.x =0.5
					tile.anchor.y = 1;

					if(mouseMode == 3){
						tile.alpha = .7;
					}

					tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
					tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

					tile.hitArea = new PIXI.Polygon(new PIXI.Point(0, 0), new PIXI.Point(-tileWidth/2, -tileHeight/2), new PIXI.Point(0, -tileHeight), new PIXI.Point(tileWidth/2, -tileHeight/2));

					tile.interactive = true;

					tile.mousedown = function(data){
            var ci = 0;
            var cj = 0;
            var close = 1000;
            for(var i = 0; i < sizeX; i++){
              for(var j = 0; j < sizeY; j++){
                var distance = Math.abs((sizeY - 1 + i - j) * (tileWidth/2) + start - this.position.x) + (Math.abs((i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2) - this.position.y) * 1.5);
                if(distance < close){
                  ci = i;
                  cj = j;
                  close = distance;
                }
              }
            }
						if(shift){
							fillNext.x = ci;
							fillNext.y = cj;
							fillNext.on = true;
							fillIcon = new PIXI.Sprite(fillTexture);
							fillIcon.anchor.x = 0.5;
							fillIcon.anchor.y = 1;
							fillIcon.position.x = (sizeY - 1 + ci - cj) * (tileWidth/2) + start;
							fillIcon.position.y = (ci + cj) * (tileHeight/2) + start - (sideHeight * map[ci][cj].h);
							fillContainer.addChild(fillIcon);
						}else{
							if(fillNext.on){
								fillNext.on = false;
								var x1 = ci;
								var x2 = fillNext.x;
								var y1 = cj;
								var y2 = fillNext.y;
								if(fillNext.x < ci){
									x1 = fillNext.x;
									x2 = ci;
								}
								if(fillNext.y < cj){
									y1 = fillNext.y;
									y2 = cj;
								}
								for(var k = x1; k <= x2; k++){
									for(var l = y1; l <= y2; l++){
										changeTile(k, l);
									}
								}
								fillContainer.removeChild(fillContainer.getChildAt(0));
							}else{
								changeTile(ci, cj);
							}
						}
						reload();
						drawMap();
					}

					levels[i + j].addChild(tile);

					for(var k = map[i][j].h; k > 0; k--){
						if(i == sizeX - 1 || k > map[i+1][j].h){
							var under = new PIXI.Sprite(sideTexture[tileSet][map[i][j].side]);

							under.anchor.x = 0.5;
							tile.anchor.y = 1;

              if(mouseMode == 3){
                under.alpha = .7;
              }

							under.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
							under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

							levels[i + j].addChild(under);
						}

						if(j == sizeY - 1 || k > map[i][j+1].h){
							var under2 = new PIXI.Sprite(sideTexture[tileSet][map[i][j].side]);

							under2.anchor.x = 0.5;
							tile.anchor.y = 1;

              if(mouseMode == 3){
                under2.alpha = .7;
              }

							under2.scale.x = -1;

							under2.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
							under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k) - 1;

							levels[i + j].addChild(under2);
						}
					}
          //Collision markers
          if(map[i][j].cr){
            var cm = new PIXI.Sprite(collTexture);

            cm.anchor.x = 0.5;
            cm.anchor.y = 1;

            if(mouseMode != 3){
              cm.alpha = 0;
            }

            cm.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
            cm.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

            levels[i + j + 1].addChild(cm);
          }
          if(map[i][j].cl){
            var cm = new PIXI.Sprite(collTexture);

            cm.anchor.x = 0.5;
            cm.anchor.y = 1;

            cm.scale.x = -1;

            if(mouseMode != 3){
              cm.alpha = 0;
            }

            cm.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
            cm.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

            levels[i + j + 1].addChild(cm);
          }

					//Objects
					if(map[i][j].env != 0){
						var env = new PIXI.Sprite(envTexture[map[i][j].env]);

						env.anchor.x = 0.5
						env.anchor.y = 1;

            if(mouseMode == 3){
              env.alpha = .7;
            }

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h);

						envLevels[i + j].addChild(env);
					}
					if(map[i][j].envc != 0){
						var env = new PIXI.Sprite(envcTexture[map[i][j].envc]);

						env.anchor.x = 0.5
						env.anchor.y = 1;

            if(mouseMode == 3){
              env.alpha = .7;
            }

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

						levels[i + j + 1].addChild(env);
					}
				}
			}
		}
	</script>
</body>
