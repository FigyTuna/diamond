<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Diamond Game</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #303030;
		}
	</style>
	<script src="pixi.js"></script>
</head>
<body>
	<script>

		//PIXI Stuff

		var stage = new PIXI.Stage(0x505050);
		var renderer = PIXI.autoDetectRenderer(1000, 600); //Should make the size the size of the window eventually.
		document.body.appendChild(renderer.view);
		requestAnimFrame(animate);

		//------------------------------------ TEXTURES (temporary)

		var personTexture = PIXI.Texture.fromImage("images/character/guy.png");

		var tileTexture = PIXI.Texture.fromImage("images/tile/grass/top.png");

		var underTexture = PIXI.Texture.fromImage("images/tile/grass/side.png");

		var envTexture = PIXI.Texture.fromImage("images/object/tree.png");

		var envTexture2 = PIXI.Texture.fromImage("images/object/fenceL.png");

		//----------------------------------- VARIABLES

		versionNumber = "0.0.1 (Alpha)";

		var area = new PIXI.DisplayObjectContainer(); //Main game container.
		stage.addChild(area);

		var start = 100; //Depends on other things. Should be centered. Scrolling landscapes too. //FINAL
		var layers = 50; //Temp variable. Don't know what this will eventually be. //FINAL

		var tileWidth = 50; //Size of the tile images in pixels
		var tileHeight = 24;
		var sideHeight = 9;

		var left = false; //Keyboard inputs.
		var up = false;
		var right = false;
		var down = false;

		var lr = 0; //Distance in left, right, up, and down that the player will be in the next tick.
		var ud = 0;

		var lastZi = 0; //Where the player was last tick.
		var lastZj = 0;

		var speed = 3; //Speed the player travels. Maybe this will be altered during game play.

		//------------------------------------- New map

		var sizeX = 14;
		var sizeY = 14;

		var map = new Array(sizeX);
		for(var i = 0; i < map.length; i++){
			map[i] = new Array(sizeY);
		}

		for(var i = 0; i < sizeX; i++){
			for(var j = 0; j < sizeY; j++){
				map[i][j] = {
					h: 0,
					top: 0,
					side: 0,
					env: 0,
					cr: false, // lower right (collisions)
					cl: false, // lower left
					//NPC and loading zone data goes in here too.
				}
			}
		}

		//------------------------------------- TEMP MAP

		for(var i = sizeX - 2; i > 0; i--){
			map[1][i].h = i;
			map[i][1].h = i;
		}
		map[2][2].h = 1;

		map[9][9].h = 3;

		map[5][6].h = 2;
		map[6][6].h = 1;
		map[5][5].h = 3;
		map[6][5].h = 2;

		map[5][2].h = 2;
		map[6][2].h = 2;
		map[6][3].h = 2;

		//---- Object map (also temporary)

		for(var i = 4; i < 7; i++){
			for(var j = 5; j < 9; j++){
				map[j][i].env = 1;
			}
		}

		map[6][9].env = 2;
		map[6][9].cl = true;
		map[7][9].env = 2;
		map[7][9].cl = true;
		map[7][10].env = 2;
		map[7][10].cl = true;

		//---------------------------- Map things

		var levels = new Array(layers);
		for(var i = 0; i < layers; i++){
			levels[i] = new PIXI.DisplayObjectContainer();
		}
		var envLevels = new Array(layers);
		for(var i = 0; i < layers; i++){
			envLevels[i] = new PIXI.DisplayObjectContainer();
		}

		//------------------------------------- TILES

		drawMap();

		//--------------------------------------- PERSON

		var person = new PIXI.Sprite(personTexture);

		var guyx = (sizeY - 1 + lastZi - lastZj) * (tileWidth/2) + start;
		var guyy = (lastZi + lastZj) * (tileHeight/2) + start;

		person.anchor.x = 0.5;
		person.anchor.y = 1;

		person.position.x = guyx;
		person.position.y = guyy;

		area.addChild(person);

		//---------------------------------------- Version text

		var version = new PIXI.Text("Version: " + versionNumber, {font: "12px Arial", fill: "white"});

		version.position.x = version.position.y = 10;

		stage.addChild(version);

		//-------------------------------------------- INPUT

		document.addEventListener('keydown', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = true;
			}
			if(code == 87 || code == 38){ //W
				up = true;
			}
			if(code == 68 || code == 39){ //D
				right = true;
			}
			if(code == 83 || code == 40){ //S
				down = true;
			}

		})

		document.addEventListener('keyup', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = false;
			}
			if(code == 87 || code == 38){ //W
				up = false;
			}
			if(code == 68 || code == 39){ //D
				right = false;
			}
			if(code == 83 || code == 40){ //S
				down = false;
			}
		})

		//--------------------------------------------------------------------- GAME LOOP

		function animate(){
			requestAnimFrame(animate);

			update();

			renderer.render(stage);
		}

		function update(){

			//Movement

			if(left){
				lr = -speed;
			}
			if(up){
				ud = -speed * 0.5;
			}
			if(right){
				lr = speed;
			}
			if(down){
				ud = speed * 0.5;
			}
			if(left && right){
				lr = 0;
			}
			if(up && down){
				ud = 0;
			}

			guyx += lr;
			guyy += ud;

			// What tile the player is on.

			var ci = 0;
			var cj = 0;
			var close = 1000;
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					var distance = Math.abs((sizeY - 1 + i - j) * (tileWidth/2) + start - guyx) + (Math.abs((i + j) * (tileHeight/2) + start - guyy) * 1.5); //current
					if(distance < close){
						ci = i;
						cj = j;
						close = distance;
					}
				}
			}

			//Collision correction
			//Still clunky and stick. The code is messy too. But it works even better than it did before.

			var col = false;
			if(map[ci][cj].h - map[lastZi][lastZj].h > 1 || map[ci][cj].h - map[lastZi][lastZj].h < -2){
				col = true;
			}
			if(map[lastZi][lastZj].cr && ci > lastZi){
				col = true;
			}
			if(map[lastZi][lastZj].cl && cj > lastZj){
				col = true;
			}
			if(map[ci][cj].cr && ci < lastZi){
				col = true;
			}
			if(map[ci][cj].cl && cj < lastZj){
				col = true;
			}

			if(col){
				guyx -= lr;
				guyy -= ud;
				if(!(ci != lastZi && cj != lastZj)){
					if(ci > lastZi){ // bottom right
						if(right && !down){
							guyx += speed;
							guyy += -speed * 0.55;
						}else if(down && !right){
							guyx += -speed;
							guyy += speed * 0.4;
						}
					}
					if(ci < lastZi){ // top left
						if(left && !up){
							guyx += -speed;
							guyy += speed * 0.55;
						}else if(up && !left){
							guyx += speed;
							guyy += -speed * 0.4;
						}
					}
					if(cj > lastZj){ // bottom left
						if(left && !down){
							guyx += -speed;
							guyy += -speed * 0.55;
						}else if(down && !left){
							guyx += speed;
							guyy += speed * 0.4;
						}
					}
					if(cj < lastZj){ // top right
						if(right && !up){
							guyx += speed;
							guyy += speed * 0.55;
						}else if(up && !right){
							guyx += -speed;
							guyy += -speed * 0.4;
						}
					}
				}else{
					//env collision when moving up or down doesn't work because these if else statements don't include support for envs. They don't suppoet them because it'd be tedious and messy to do that.
					//up works going left and down works going right because those are default directions.
					if(lastZi - 1 == ci && lastZj - 1 == cj){ //Up
						if(Math.abs(map[lastZi][lastZj - 1].h - map[lastZi][lastZj].h) > 1 && !(Math.abs(map[lastZi - 1][lastZj].h - map[lastZi][lastZj].h) > 1)){
							guyx += -speed;
							guyy += -speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj - 1].h - map[lastZi][lastZj].h) > 1) && Math.abs(map[lastZi - 1][lastZj].h - map[lastZi][lastZj].h) > 1){
							guyx += speed;
							guyy += -speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj - 1].h - map[lastZi][lastZj].h) > 1) && !(Math.abs(map[lastZi - 1][lastZj].h - map[lastZi][lastZj].h) > 1)){
							guyx += -speed;
							guyy += -speed * 0.4;
						}
					}
					if(lastZi + 1 == ci && lastZj + 1 == cj){ //Down
						if(Math.abs(map[lastZi][lastZj + 1].h - map[lastZi][lastZj].h) > 1 && !(Math.abs(map[lastZi + 1][lastZj].h - map[lastZi][lastZj].h) > 1)){
							guyx += speed;
							guyy += speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj + 1].h - map[lastZi][lastZj].h) > 1) && Math.abs(map[lastZi + 1][lastZj].h - map[lastZi][lastZj].h) > 1){
							guyx += -speed;
							guyy += speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj + 1].h - map[lastZi][lastZj].h) > 1) && !(Math.abs(map[lastZi + 1][lastZj].h - map[lastZi][lastZj].h) > 1)){
							guyx += -speed;
							guyy += speed * 0.4;
						}
					}
				}

				ci = lastZi;
				cj = lastZj;
			}

			//Raising to correct height visually.

			var offset = 9 * map[ci][cj].h;

			//Slow down

			lr /= 1.35;
			ud /= 1.35;

			if(Math.abs(lr) < 0.001){
				lr = 0;
			}
			if(Math.abs(ud) < 0.001){
				ud = 0;
			}

			//Person Placement
			//Eventually this will change with screen scrolling.

			person.position.x = guyx;
			person.position.y = guyy - offset;

			//Map and layers
			while(area.children.length > 0){
				area.removeChild(area.getChildAt(0));
			}
			for(var i = 0; i < layers; i++){ //<
				if(i <= ci + cj){
					area.addChild(levels[i]);
					area.addChild(envLevels[i]);
				}else if(i == ci + cj + 1){
					if((ci + cj) * (tileHeight/2) + start - guyy < 0){
						area.addChild(envLevels[i - 1]);
						area.addChild(person);
					}else{
						area.addChild(person);
						area.addChild(envLevels[i - 1]);
					}
				}else{
					area.addChild(levels[i - 1]);
					area.addChild(envLevels[i - 1]);
				}
			}

			//Last tick
			lastZi = ci;
			lastZj = cj;
		}

		//Drawing

		function drawMap(){
			for(var i = 0; i < sizeX; i++){
				for(var j = 0; j < sizeY; j++){
					var tile = new PIXI.Sprite(tileTexture);

					tile.anchor.x = tile.anchor.y = 0.5;

					tile.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
					tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h);

					levels[i + j].addChild(tile);

					for(var k = map[i][j].h; k > 0; k--){
						if(i == sizeX - 1 || k > map[i+1][j].h){
							var under = new PIXI.Sprite(underTexture);

							under.anchor.x = tile.anchor.y = 0.5;

							under.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
							under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k);

							levels[i + j].addChild(under);
						}

						if(j == sizeY - 1 || k > map[i][j+1].h){
							var under2 = new PIXI.Sprite(underTexture);

							under2.anchor.x = tile.anchor.y = 0.5;

							under2.scale.x = -1;

							under2.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
							under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k);

							levels[i + j].addChild(under2);
						}
					}

					//Objects
					if(map[i][j].env == 1){ //Expand for more objects
						var env = new PIXI.Sprite(envTexture);

						env.anchor.x = 0.5
						env.anchor.y = 1;

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h);

						envLevels[i + j].addChild(env);
					}
					if(map[i][j].env == 2){
						var env = new PIXI.Sprite(envTexture2);

						env.anchor.x = 0.5
						env.anchor.y = 1;

						env.position.x = (sizeY - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j].h) + (tileHeight/2);

						levels[i + j + 1].addChild(env);
					}
				}
			}
		}
	</script>
</body>
