<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Diamond Game</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #303030;
		}
	</style>
	<script src="pixi.js"></script>
</head>
<body>
	<script>

		//PIXI Stuff

		var stage = new PIXI.Stage(0x505050);
		var renderer = PIXI.autoDetectRenderer(1000, 600); //Should make the size the size of the window eventually.
		document.body.appendChild(renderer.view);
		requestAnimFrame(animate);

		//------------------------------------ TEXTURES (temporary)

		var personTexture = PIXI.Texture.fromImage("images/character/guy.png");

		var tileTexture = PIXI.Texture.fromImage("images/tile/grass/top.png");

		var underTexture = PIXI.Texture.fromImage("images/tile/grass/side.png");

		var envTexture = PIXI.Texture.fromImage("images/object/tree.png");

		//----------------------------------- MOVEMENT VARIABLES

		var area = new PIXI.DisplayObjectContainer(); //Main game container.
		stage.addChild(area);

		var size = 14; //FINAL VALUES //Temporary variable controlling the map size. Needs to be here for the placement algorythm.
		var start = 100; //Depends on other things. Should be centered. Scrolling landscapes too.
		var layers = 50; //Temp variable. Don't know what this will eventually be.

		var tileWidth = 50; //Size of the tiles
		var tileHeight = 24;
		var sideHeight = 9;

		var left = false; //Keyboard inputs.
		var up = false;
		var right = false;
		var down = false;

		var lr = 0; //Distance in left, right, up, and down that the player will be in the next tick.
		var ud = 0;

		var lastZi = 0; //Where the player was last tick.
		var lastZj = 0;

		var speed = 3; //Speed the player travels.

		//------------------------------------- TEMP MAP

		var map = new Array(size);
		for(var i = 0; i < map.length; i++){
			map[i] = new Array(size);
		}
		for(var i = 0; i < map.length; i++){
			for(var j = 0; j < map[0].length; j++){
				map[i][j] = 0;
			}
		}
		for(var i = map.length - 2; i > 0; i--){
			map[1][i] = i;
			map[i][1] = i;
		}
		map[2][2] = 1;

		map[9][9] = 3;

		map[5][6] = 2;
		map[6][6] = 1;
		map[5][5] = 3;
		map[6][5] = 2;

		map[5][2] = 2;
		map[6][2] = 2;
		map[6][3] = 2;

		//---- Object map (also temporary)

		var envMap = new Array(map.length);
		for(var i = 0; i < envMap.length; i++){
			envMap[i] = new Array(map.length);
		}
		for(var i = 0; i < envMap.length; i++){
			for(var j = 0; j < envMap[0].length; j++){
				envMap[i][j] = 0; // Should be set to object objects as well as tiles to tile objects
			}
		}

		for(var i = 4; i < 7; i++){
			for(var j = 5; j < 9; j++){
				envMap[j][i] = 1;
			}
		}

		envMap[0][0] = 1;
		envMap[6][9] = 1;
		envMap[7][9] = 1;
		envMap[7][10] = 1;

		//---------------------------- Map things

		var levels = new Array(layers);
		for(var i = 0; i < layers; i++){
			levels[i] = new PIXI.DisplayObjectContainer();
		}
		var envLevels = new Array(layers);
		for(var i = 0; i < layers; i++){
			envLevels[i] = new PIXI.DisplayObjectContainer();
		}

		//------------------------------------- TILES

		drawMap();

		//--------------------------------------- PERSON

		var person = new PIXI.Sprite(personTexture);

		var guyx = start * 3;
		var guyy = start * 3;

		person.anchor.x = 0.5;
		person.anchor.y = 1;

		person.position.x = guyx;
		person.position.y = guyy;

		area.addChild(person);

		//-------------------------------------------- INPUT

		document.addEventListener('keydown', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = true;
			}
			if(code == 87 || code == 38){ //W
				up = true;
			}
			if(code == 68 || code == 39){ //D
				right = true;
			}
			if(code == 83 || code == 40){ //S
				down = true;
			}

		})

		document.addEventListener('keyup', function(event){
			var code = event.keyCode;

			if(code == 65 || code == 37){ //A
				left = false;
			}
			if(code == 87 || code == 38){ //W
				up = false;
			}
			if(code == 68 || code == 39){ //D
				right = false;
			}
			if(code == 83 || code == 40){ //S
				down = false;
			}
		})

		//--------------------------------------------------------------------- GAME LOOP

		function animate(){
			requestAnimFrame(animate);

			update();

			renderer.render(stage);
		}

		function update(){

			//Movement

			if(left){
				lr = -speed;
			}
			if(up){
				ud = -speed * 0.5;
			}
			if(right){
				lr = speed;
			}
			if(down){
				ud = speed * 0.5;
			}
			if(left && right){
				lr = 0;
			}
			if(up && down){
				ud = 0;
			}

			guyx += lr;
			guyy += ud;

			// What tile the player is on.

			var ci = 0;
			var cj = 0;
			var close = 1000;
			for(var i = 0; i < map.length; i++){
				for(var j = 0; j < map[0].length; j++){
					var distance = Math.abs((map.length - 1 + i - j) * (tileWidth/2) + start - guyx) + (Math.abs((i + j) * (tileHeight/2) + start - guyy) * 1.5); //current
					if(distance < close){
						ci = i;
						cj = j;
						close = distance;
					}
				}
			}

			//Collision correction version 2
			//Still clunky and stick. The code is messy too. But it works even better than it did before.

			if(Math.abs(map[ci][cj] - map[lastZi][lastZj]) > 1){ //Or env is in the way
				guyx -= lr;
				guyy -= ud;
				if(!(ci != lastZi && cj != lastZj)){
					if(ci > lastZi){ // bottom right
						if(right && !down){
							guyx += speed;
							guyy += -speed * 0.55;
						}else if(down && !right){
							guyx += -speed;
							guyy += speed * 0.5;
						}
					}
					if(ci < lastZi){ // top left
						if(left && !up){
							guyx += -speed;
							guyy += speed * 0.55;
						}else if(up && !left){
							guyx += speed;
							guyy += -speed * 0.5;
						}
					}
					if(cj > lastZj){ // bottom left
						if(left && !down){
							guyx += -speed;
							guyy += -speed * 0.55;
						}else if(down && !left){
							guyx += speed;
							guyy += speed * 0.5;
						}
					}
					if(cj < lastZj){ // top right
						if(right && !up){
							guyx += speed;
							guyy += speed * 0.55;
						}else if(up && !right){
							guyx += -speed;
							guyy += -speed * 0.5;
						}
					}
				}else{
					if(lastZi - 1 == ci && lastZj - 1 == cj){ //Up
						if(Math.abs(map[lastZi][lastZj - 1] - map[lastZi][lastZj]) > 1 && !(Math.abs(map[lastZi - 1][lastZj] - map[lastZi][lastZj]) > 1)){
							guyx += -speed;
							guyy += -speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj - 1] - map[lastZi][lastZj]) > 1) && Math.abs(map[lastZi - 1][lastZj] - map[lastZi][lastZj]) > 1){
							guyx += speed;
							guyy += -speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj - 1] - map[lastZi][lastZj]) > 1) && !(Math.abs(map[lastZi - 1][lastZj] - map[lastZi][lastZj]) > 1)){
							guyx += -speed;
							guyy += -speed * 0.4;
						}
					}
					if(lastZi + 1 == ci && lastZj + 1 == cj){ //Down
						if(Math.abs(map[lastZi][lastZj + 1] - map[lastZi][lastZj]) > 1 && !(Math.abs(map[lastZi + 1][lastZj] - map[lastZi][lastZj]) > 1)){
							guyx += speed;
							guyy += speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj + 1] - map[lastZi][lastZj]) > 1) && Math.abs(map[lastZi + 1][lastZj] - map[lastZi][lastZj]) > 1){
							guyx += -speed;
							guyy += speed * 0.4;
						}else if(!(Math.abs(map[lastZi][lastZj + 1] - map[lastZi][lastZj]) > 1) && !(Math.abs(map[lastZi + 1][lastZj] - map[lastZi][lastZj]) > 1)){
							guyx += -speed;
							guyy += speed * 0.4;
						}
					}
				}

				ci = lastZi;
				cj = lastZj;
			}

			//Raising to correct height visually.

			var offset = 9 * map[ci][cj];

			//Slow down

			lr /= 1.35;
			ud /= 1.35;

			if(Math.abs(lr) < 0.001){
				lr = 0;
			}
			if(Math.abs(ud) < 0.001){
				ud = 0;
			}

			//Person Placement
			//Eventually this will change with screen scrolling.

			person.position.x = guyx;
			person.position.y = guyy - offset;

			//Map and layers
			while(area.children.length > 0){
				area.removeChild(area.getChildAt(0));
			}
			for(var i = 0; i < layers; i++){ //<
				if(i <= ci + cj){
					area.addChild(levels[i]);
					area.addChild(envLevels[i]);
				}else if(i == ci + cj + 1){
					if((ci + cj) * (tileHeight/2) + start - guyy < 0){
						area.addChild(envLevels[i - 1]);
						area.addChild(person);
					}else{
						area.addChild(person);
						area.addChild(envLevels[i - 1]);
					}
				}else{
					area.addChild(levels[i - 1]);
					area.addChild(envLevels[i - 1]);
				}
			}

			//Last tick
			lastZi = ci;
			lastZj = cj;
		}

		//Drawing

		function drawMap(){
			for(var i = 0; i < map.length; i++){
				for(var j = 0; j < map.length; j++){
					var tile = new PIXI.Sprite(tileTexture);

					tile.anchor.x = tile.anchor.y = 0.5;

					tile.position.x = (size - 1 + i - j) * (tileWidth/2) + start;
					tile.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j]);

					levels[i + j].addChild(tile);

					for(var k = map[i][j]; k > 0; k--){
						if(i == map.length - 1 || k > map[i+1][j]){
							var under = new PIXI.Sprite(underTexture);

							under.anchor.x = tile.anchor.y = 0.5;

							under.position.x = (size - 1 + i - j) * (tileWidth/2) + start + (tileWidth/4);
							under.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k);

							levels[i + j].addChild(under);
						}

						if(j == map.length - 1 || k > map[i][j+1]){
							var under2 = new PIXI.Sprite(underTexture);

							under2.anchor.x = tile.anchor.y = 0.5;

							under2.scale.x = -1;

							under2.position.x = (size - 1 + i - j) * (tileWidth/2) + start - (tileWidth/4);
							under2.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * k);

							levels[i + j].addChild(under2);
						}
					}

					//Objects
					if(envMap[i][j] == 1){ //Expand for more objects
						var env = new PIXI.Sprite(envTexture);

						env.anchor.x = 0.5
						env.anchor.y = 1;

						env.position.x = (size - 1 + i - j) * (tileWidth/2) + start;
						env.position.y = (i + j) * (tileHeight/2) + start - (sideHeight * map[i][j]);

						envLevels[i + j].addChild(env);
					}
				}
			}
		}
	</script>
</body>
